\ This is where things get interesting.
\ The new Forth generated by this process will work differently from the seed.
\ TODO elaborate

: INLINE  HERE MOVE ;
:! {  POSTPONE AHEAD  HERE SWAP ;
:! }  POSTPONE THEN  DUP LITERAL  HERE - NEGATE LITERAL ;

\ TODO Redefine primitives to inline their contents

\ :! DUP  { RDX PUSHQ  RDX RAX MOVQ } INLINE ;
\ :! DROP  { RAX RDX MOVQ  RDX POPQ } INLINE ;
\ :! SWAP  { RDX RAXXCHGQ } INLINE ;
\ :! NIP  { RDX POPQ } INLINE ;

:! PUSHA  FOR AFT POSTPONE PUSHQ THEN NEXT ;
:! POPA  FOR AFT POSTPONE POPQ THEN NEXT ;


[ $ 400000 ] CONSTANT LOAD-ADDR
[ $ 42000 ] CONSTANT EXTRA-MEM
VARIABLE ELF-HEADER

:! ENTRY  NAME FIND ELF-HEADER @ - LOAD-ADDR +  ELF-HEADER @ $ 18 + ! ;
: UPDATE-SIZE  HERE ELF-HEADER @ - DUP  ELF-HEADER @ $ 60 + !  EXTRA-MEM + ELF-HEADER @ $ 68 + ! ;
:! DUMP-BINARY  UPDATE-SIZE ELF-HEADER @ HERE OVER - TYPE  BYE ;

[ HERE ELF-HEADER ! ]

[
	\ ELF Header
	$ 464C457F D, \ EI_MAG ("\x7fELF")
	$ 2 C, \ EI_CLASS (64-bit format)
	$ 1 C, \ EI_DATA (little endian)
	$ 1 C, \ EI_VERSION (1)
	$ 0 C, \ EI_OSABI (System V)
	$ 0 , \ EI_ABIVERSION, EI_PAD
	$ 2 W, \ e_type (ET_EXEC)
	$ 3E W, \ e_machine (x86-64)
	$ 1 D, \ e_version (1)
	LOAD-ADDR , \ e_entry (TBD)
	$ 40 , \ e_phoff
	$ 0 , \ e_shoff
	$ 0 D, \ e_flags
	$ 40 W, \ e_ehsize
	$ 38 W, \ e_phentsize
	$ 1 W, \ e_phnum
	$ 40 W, \ e_shentsize
	$ 0 W, \ e_shnum
	$ 0 W, \ e_shstrndx

	\ Program Header
	$ 1 D, \ p_type
	$ 7 D, \ p_flags
	$ 0 , \ p_offset
	LOAD-ADDR , \ p_vaddr
	LOAD-ADDR , \ p_paddr
	$ 78 , \ p_filesz
	$ 78 , \ p_memsz
	$ 1000 , \ p_align
]

:! START
	RAX [ $ 3C ] MOVQ$
	RDI [ $ 4D ] MOVQ$
	SYSCALLQ

ENTRY START
DUMP-BINARY
